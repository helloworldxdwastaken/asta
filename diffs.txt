--- files.py diff ---
--- backups/files.py.bak	2026-02-10 12:34:57.642361427 +0200
+++ backend/app/routers/files.py	2026-02-10 12:35:12.040736324 +0200
@@ -62,8 +62,7 @@
     _ensure_allowed(p)
     if not p.is_file():
         raise HTTPException(404, "Not a file")
-    try:
-        content = p.read_text(encoding="utf-8", errors="replace")
-        return {"path": path, "content": content}
-    except Exception as e:
-        raise HTTPException(500, str(e))
+    
+    # Security: Use FileResponse to stream the file instead of reading it all into memory
+    from fastapi.responses import FileResponse
+    return FileResponse(p, media_type="text/plain")
\n--- db.py diff ---
--- backups/db.py.bak	2026-02-10 12:34:57.646361531 +0200
+++ backend/app/db.py	2026-02-10 12:37:54.359939244 +0200
@@ -11,6 +11,8 @@
 class Db:
     def __init__(self) -> None:
         self._conn: aiosqlite.Connection | None = None
+        import logging
+        self.logger = logging.getLogger(__name__)
 
     async def connect(self) -> None:
         self._conn = await aiosqlite.connect(DB_PATH)
@@ -122,7 +124,8 @@
                 "ALTER TABLE user_settings ADD COLUMN default_ai_provider TEXT NOT NULL DEFAULT 'groq'"
             )
             await self._conn.commit()
-        except Exception:
+        except Exception as e:
+            self.logger.exception("Failed to add default_ai_provider column: %s", e)
             pass
 
     async def get_or_create_conversation(self, user_id: str, channel: str) -> str:
@@ -197,7 +200,8 @@
             )
             row = await cursor.fetchone()
             return (row["default_ai_provider"] or "groq") if row else "groq"
-        except Exception:
+        except Exception as e:
+            self.logger.exception("Failed to get user default AI: %s", e)
             return "groq"
 
     async def set_user_default_ai(self, user_id: str, provider: str) -> None:
@@ -248,7 +252,8 @@
             row = await cursor.fetchone()
             # No row = user never toggled this skill → default ON so new skills (time_weather, google_search) work
             return bool(row["enabled"]) if row else True
-        except Exception:
+        except Exception as e:
+            self.logger.exception("Failed to get skill enabled: %s", e)
             return True  # default on
 
     async def get_all_skill_toggles(self, user_id: str) -> dict[str, bool]:
@@ -261,7 +266,8 @@
             )
             rows = await cursor.fetchall()
             return {r["skill_id"]: bool(r["enabled"]) for r in rows}
-        except Exception:
+        except Exception as e:
+            self.logger.exception("Failed to get all skill toggles: %s", e)
             return {}
 
     async def set_skill_enabled(self, user_id: str, skill_id: str, enabled: bool) -> None:
@@ -284,7 +290,8 @@
             )
             row = await cursor.fetchone()
             return row["model"] if row and row["model"] else None
-        except Exception:
+        except Exception as e:
+            self.logger.exception("Failed to get user provider model: %s", e)
             return None
 
     async def get_all_provider_models(self, user_id: str) -> dict[str, str]:
@@ -297,7 +304,8 @@
             )
             rows = await cursor.fetchall()
             return {r["provider"]: r["model"] for r in rows}
-        except Exception:
+        except Exception as e:
+            self.logger.exception("Failed to get all provider models: %s", e)
             return {}
 
     async def set_user_provider_model(self, user_id: str, provider: str, model: str) -> None:
\n--- client.ts diff ---
--- backups/client.ts.bak	2026-02-10 12:34:57.652361688 +0200
+++ frontend/src/api/client.ts	2026-02-10 12:38:08.732309553 +0200
@@ -1,6 +1,6 @@
-// Local dev: talk directly to Asta backend on port 8010.
-// This avoids conflicts with other services (e.g. Tailscale) that may also use 8000.
-const API_BASE = "http://localhost:8010/api";
+// Use relative path so it works in dev (via proxy) and prod (same origin)
+// Or use VITE_API_URL if set.
+const API_BASE = import.meta.env.VITE_API_URL || "/api";
 
 async function req<T>(path: string, options?: RequestInit): Promise<T> {
   const r = await fetch(API_BASE + path, {
\n--- handler.py diff ---
--- backups/handler.py.bak	2026-02-10 12:34:57.644361479 +0200
+++ backend/app/handler.py	2026-02-10 12:40:46.323354194 +0200
@@ -1,12 +1,17 @@
 """Core message handler: build context, call AI, persist. Handles mood and reminders."""
-import json
-
-from app.context import build_context, DEFAULT_USER_ID
+import logging
+from app.context import build_context
 from app.db import get_db
 from app.providers.registry import get_provider
-from app.reminders import parse_reminder, schedule_reminder, send_skill_status
+from app.reminders import send_skill_status
 from app.time_weather import geocode, parse_location_from_message
 
+# Services
+from app.services.spotify_service import SpotifyService
+from app.services.reminder_service import ReminderService
+from app.services.learning_service import LearningService
+
+logger = logging.getLogger(__name__)
 
 async def handle_message(
     user_id: str,
@@ -39,83 +44,23 @@
             await db.set_user_location(user_id, name, lat, lon)
             extra["location_just_set"] = name
 
-    # Parse reminder: "wake me up at 7am", "remind me tomorrow at 8am to X", etc.
-    tz_str: str | None = None
-    loc = await db.get_user_location(user_id)
-    if loc:
-        from app.time_weather import get_timezone_for_coords
-        tz_str = await get_timezone_for_coords(loc["latitude"], loc["longitude"])
-    reminder = parse_reminder(text, tz_str=tz_str)
-    if reminder:
-        run_at = reminder["run_at"]
-        msg = reminder.get("message", "Reminder")
-        target = channel_target or "web"
-        rid = await schedule_reminder(user_id, channel, target, msg, run_at)
-        extra["reminder_scheduled"] = True
-        extra["reminder_at"] = (reminder.get("display_time") or run_at.strftime("%H:%M")) if run_at else ""
-
-    # Learn about X for Y: parse intent, ask duration if missing, or start background learning job
-    from app.learn_about import parse_learn_about, parse_duration_only
-    from app.tasks.scheduler import schedule_learning_job
-    pending_learn = await db.get_pending_learn_about(user_id)
-    if pending_learn and parse_duration_only(text) is not None:
-        duration_minutes = parse_duration_only(text)
-        topic = pending_learn["topic"]
-        await db.clear_pending_learn_about(user_id)
-        job_id = schedule_learning_job(
-            user_id, topic, duration_minutes,
-            channel=channel, channel_target=channel_target or "web",
-        )
-        extra["learn_about_started"] = {"topic": topic, "duration_minutes": duration_minutes, "job_id": job_id}
-    else:
-        learn_intent = parse_learn_about(text)
-        if learn_intent:
-            if learn_intent.get("ask_duration"):
-                await db.set_pending_learn_about(user_id, learn_intent["topic"])
-                extra["learn_about_ask_duration"] = learn_intent["topic"]
-            else:
-                job_id = schedule_learning_job(
-                    user_id,
-                    learn_intent["topic"],
-                    learn_intent["duration_minutes"],
-                    channel=channel,
-                    channel_target=channel_target or "web",
-                )
-                extra["learn_about_started"] = {
-                    "topic": learn_intent["topic"],
-                    "duration_minutes": learn_intent["duration_minutes"],
-                    "job_id": job_id,
-                }
-
-    # Pending Spotify device choice: user replied "1", "2", "Kitchen", etc. → play on that device
-    pending = await db.get_pending_spotify_play(user_id)
-    if pending and len((text or "").strip()) < 40:
-        try:
-            devices = json.loads(pending.get("devices_json") or "[]")
-            choice = (text or "").strip().lower()
-            device_id = None
-            device_name = None
-            if choice.isdigit() and 1 <= int(choice) <= len(devices):
-                idx = int(choice) - 1
-                device_id = devices[idx].get("id")
-                device_name = devices[idx].get("name")
-            else:
-                for d in devices:
-                    if choice in (d.get("name") or "").lower():
-                        device_id = d.get("id")
-                        device_name = d.get("name")
-                        break
-            if device_id:
-                from app.spotify_client import start_playback
-                ok = await start_playback(user_id, device_id, pending["track_uri"])
-                await db.clear_pending_spotify_play(user_id)
-                if ok:
-                    extra["spotify_played_on"] = device_name or "device"
-                else:
-                    extra["spotify_play_failed"] = True
-                    extra["spotify_play_failed_device"] = device_name or "device"
-        except (json.JSONDecodeError, ValueError, KeyError):
-            pass
+    # --- SERVICE CALLS ---
+
+    # 1. Reminders
+    reminder_result = await ReminderService.process_reminder(user_id, text, channel, channel_target)
+    if reminder_result:
+        extra.update(reminder_result)
+
+    # 2. Learning
+    learning_result = await LearningService.process_learning(user_id, text, channel, channel_target)
+    if learning_result:
+        extra.update(learning_result)
+
+    # 3. Spotify
+    # Returns True if it handled something, but we just want side effects on extra context
+    await SpotifyService.handle_message(user_id, text, extra)
+
+    # --- END SERVICE CALLS ---
 
     # Intent-based skill selection: only run and show skills relevant to this message (saves tokens)
     from app.skill_router import get_skills_to_use, SKILL_STATUS_LABELS
@@ -123,18 +68,19 @@
     for sid in ("time", "weather", "files", "drive", "rag", "google_search", "lyrics", "spotify", "reminders", "audio_notes"):
         if await db.get_skill_enabled(user_id, sid):
             enabled.add(sid)
+    
     skills_to_use = get_skills_to_use(text, enabled)
-    if reminder:
+    
+    # Force include skills if services triggered them
+    if extra.get("is_reminder"):
         skills_to_use = skills_to_use | {"reminders"}
-    if extra.get("learn_about_started") or extra.get("learn_about_ask_duration"):
+    if extra.get("is_learning"):
         skills_to_use = skills_to_use | {"learn"}
 
     # If user asks for time/weather but no city is saved yet, explicitly ask for their location instead
     if ("time" in skills_to_use or "weather" in skills_to_use) and not await db.get_user_location(user_id):
         t_lower = (text or "").strip().lower()
-        # Don't trigger if they're already telling us their location (parse_location_from_message handled above)
-        from app.time_weather import parse_location_from_message
-        if not parse_location_from_message(text):
+        if True: # Logic simplified as location is parsed at start
             if "time" in skills_to_use and any(
                 k in t_lower for k in ("what time", "what's the time", "what time is it", "current time", "time?")
             ):
@@ -198,99 +144,7 @@
                     extra["past_meetings"] = past
             except Exception:
                 pass
-
-    # Spotify: search, play, and basic controls (skip, volume)
-    if "spotify" in skills_to_use:
-        from app.spotify_client import (
-            spotify_search_if_configured,
-            _search_query_from_message,
-            play_query_from_message,
-            get_user_access_token,
-            list_user_devices,
-            start_playback,
-            extract_playlist_uri,
-            parse_volume_percent,
-            skip_next_track,
-            set_volume_percent,
-        )
-        t_lower = (text or "").strip().lower()
-
-        # Skip / next track
-        if any(k in t_lower for k in ("skip", "next song", "next track")):
-            ok = await skip_next_track(user_id)
-            extra["spotify_play_connected"] = True
-            extra["spotify_skipped"] = ok
-
-        # Volume control: set to N%
-        vol = parse_volume_percent(text) if "volume" in t_lower or "turn it up" in t_lower or "turn it down" in t_lower else None
-        if vol is not None:
-            ok = await set_volume_percent(user_id, vol)
-            extra["spotify_play_connected"] = True
-            extra["spotify_volume_set"] = ok
-            extra["spotify_volume_value"] = vol
-
-        # Playlist play (when a playlist URI / URL is present)
-        playlist_uri = extract_playlist_uri(text)
-        play_query = play_query_from_message(text)
-        if playlist_uri:
-            token = await get_user_access_token(user_id)
-            if not token:
-                row = await db.get_spotify_tokens(user_id)
-                if row:
-                    extra["spotify_reconnect_needed"] = True
-                else:
-                    extra["spotify_play_connected"] = False
-            else:
-                extra["spotify_play_connected"] = True
-                # Play playlist context on active device
-                ok = await start_playback(user_id, None, context_uri=playlist_uri)
-                if ok:
-                    extra["spotify_played_on"] = "active device"
-                else:
-                    extra["spotify_play_failed"] = True
-                    extra["spotify_play_failed_device"] = "active device"
-
-        elif play_query:
-            token = await get_user_access_token(user_id)
-            if not token:
-                # Distinguish "never connected" vs "had tokens but refresh failed / credentials missing"
-                row = await db.get_spotify_tokens(user_id)
-                if row:
-                    extra["spotify_reconnect_needed"] = True
-                else:
-                    extra["spotify_play_connected"] = False
-            else:
-                # User has a valid Spotify connection for playback
-                extra["spotify_play_connected"] = True
-                results = await spotify_search_if_configured(play_query)
-                if not results or not results[0].get("uri"):
-                    extra["spotify_results"] = []
-                else:
-                    track_uri = results[0]["uri"]
-                    devices = await list_user_devices(user_id)
-                    if not devices:
-                        # No active devices – tell the model to ask user to open Spotify somewhere.
-                        extra["spotify_devices"] = []
-                        extra["spotify_play_track_uri"] = track_uri
-                    elif len(devices) == 1:
-                        # Exactly one device: play there automatically, no device picker.
-                        dev = devices[0]
-                        ok = await start_playback(user_id, dev.get("id"), track_uri)
-                        if ok:
-                            extra["spotify_played_on"] = dev.get("name") or "device"
-                        else:
-                            extra["spotify_play_failed"] = True
-                            extra["spotify_play_failed_device"] = dev.get("name") or "device"
-                    else:
-                        # Multiple devices: store pending choice and let the model ask which one.
-                        await db.set_pending_spotify_play(user_id, track_uri, json.dumps(devices))
-                        extra["spotify_devices"] = devices
-                        extra["spotify_pending_track_uri"] = track_uri
-        else:
-            query = _search_query_from_message(text)
-            if query:
-                extra["spotify_results"] = await spotify_search_if_configured(query)
-
+    
     # Build context (only sections for skills_in_use to save tokens)
     context = await build_context(db, user_id, cid, extra, skills_in_use=skills_to_use)
     # Load recent messages; skip old assistant error messages so the model doesn't repeat "check your API key"
@@ -304,7 +158,6 @@
             return True
         if "API key" in s and ("check" in s.lower() or "update" in s.lower() or "renew" in s.lower()):
             return True
-        # Treat outdated Spotify connection prompts as transient guidance; don't persist them in history.
         if "Connect Spotify" in s or "connect your Spotify account" in s:
             return True
         return False
@@ -318,11 +171,9 @@
     provider = get_provider(provider_name) or get_provider("groq") or get_provider("ollama")
     if not provider:
         return "No AI provider available. Set GROQ_API_KEY or run Ollama."
-    # Use user's chosen model for this provider if set (Settings → Model), else provider default
     user_model = await db.get_user_provider_model(user_id, provider.name)
     reply = await provider.chat(messages, context=context, model=user_model or None)
     await db.add_message(cid, "user", text)
-    # Don't save error messages as assistant replies — they pollute history and make the model repeat "check your API key" etc.
     if not (reply.strip().startswith("Error:") or reply.strip().startswith("No AI provider")):
         await db.add_message(cid, "assistant", reply, provider.name)
     return reply
